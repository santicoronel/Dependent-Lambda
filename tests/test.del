
let eqsuc (x y : Nat) (r : x = y) : suc x = suc y := elim r {
    refl := refl
}


let cong (A : Set) (x y : A)
        (f : A -> A) (r : x = y)
        : f x = f y := elim r {
    refl := refl
}


let subst (A : Set) (P : A -> Set)
        (x y : A) (r : x = y)
        (p : P x) : P y := elim r {
    refl := p
}

let eq_elim (A : Set) (C : A -> A -> Set)
        (x y : A) (r : x = y)
        (j : (x : A) -> C x x) : C x y := elim r {
    refl := j x
}


let Bot : Set := 0 = 1
let absurd (A : Set) (p : Bot) : A := elim p {}

let rec ack (m : Nat) : Nat -> Nat :=
fix ack_m (n : Nat). elim m {
    zero := suc n ;
    suc m' := elim n {
        zero := ack m' 1 ;
        suc n := ack m' (ack_m n)
    }
}

