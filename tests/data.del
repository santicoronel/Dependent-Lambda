
data Bool : Set {
    false : Bool ;
    true : Bool
}

let is_zero (n : Nat) : Bool := elim n {
    zero := true ;
    suc _ := false
}

data eqnat : Nat -> Nat -> Set {
    zeqz : eqnat 0 0 ;
    seqs : (m n : Nat) -> eqnat m n -> eqnat (suc m) (suc n)
}

let eq2 : eqnat 2 2 := seqs 1 1 (seqs 0 0 zeqz)

let rec eqnat_refl (m : Nat) : eqnat m m := elim m {
    zero := zeqz ;
    suc m' := seqs m' m' (eqnat_refl m')
} 

let eq2eqnat (m n : Nat) (r : m = n) : eqnat m n := elim r {
    refl := eqnat_refl m
}

data Bot : Set {}

let neq12 (r : 1 = 2) : Bot := elim r {}


// Esto no pasa sort check :(    
/*

data List : (_:Set) -> Set {
    nil : (A : Set) -> List A ;
    cons : (A : Set) -> (_:A) -> (_:List A) -> List A
}

data Vec : (_:Set) -> (_:Nat) -> Set {
    nilv : (A : Set) -> Vec A 0;
    consv : (A : Set) -> (n : Nat) -> (_:A) -> (_:Vec A n) -> Vec A (suc n)
}

data Pair : (_ _:Set) -> Set {
    pair : (A B : Set) -> (_:A) -> (_:B) -> Pair A B
}

data Either : (_ _:Set) -> Set {
    left : (A B : Set) -> (_:A) -> Either A B ;
    right : (A B : Set) -> (_:B) -> Either A B
}

data Exists : (A : Set) -> (P : (_:A) -> Set) -> Set {
    ex : (A : Set) -> (P : (_:A) -> Set) -> (x : A) -> (p : P x) -> Exists A P 
}
*/

// No pasa positivity check
/*
data Bad : Set {
    bad : (_:(_:Bad) -> Bad) -> Bad
}
data Bad1 : Set {
    bad1 : (_:(_:Bad1) -> Nat) -> Bad1
}
*/

data Fin : Nat -> Set {
        fin_zero : (n : Nat) -> Fin (suc n) ;
        fin_suc  : (n : Nat) -> Fin n -> Fin (suc n) 
}

let main : Fin 3 := fin_suc 2 (fin_zero 1)